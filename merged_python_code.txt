01 - Time.py
############################################################

"""
This code calculate the time between 01-01-2026 00:00am till current
time and print it in two lines one has every format (mm,w,d,h,m) 
and the second line has only hours
"""

from datetime import datetime

start = datetime(2026, 1, 1, 0, 0)
now = datetime.now()
delta = now - start
total_minutes = int(delta.total_seconds() // 60)
total_hours = total_minutes // 60
total_days = total_hours // 24

months = total_days // 30
weeks = total_days // 7

if months >= 1:
    m = months
    d = total_days % 30
    h = total_hours % 24
    mn = total_minutes % 60
    print(f"{m} mois {d} jours {h} heures {mn} minutes")
elif weeks >= 1:
    w = weeks
    d = total_days % 7
    h = total_hours % 24
    mn = total_minutes % 60
    print(f"{w} semaines {d} jours {h} heures {mn} minutes")
else:
    d = total_days
    h = total_hours % 24
    mn = total_minutes % 60
    print(f"{d} jours {h} heures {mn} minutes")

print(f"{total_hours} heures")

# Pause the program so the window stays open
input()



02 - instagram.py
############################################################

import instaloader
import os
from pathlib import Path

def download_instagram_profile(profile_name, download_path="instagram_downloads"):
    """Download all posts, stories, and highlights from a public Instagram profile"""
    
    # Create the main download directory
    main_dir = Path(download_path) / profile_name
    main_dir.mkdir(parents=True, exist_ok=True)
    
    # Create subdirectories
    posts_dir = main_dir / "posts"
    stories_dir = main_dir / "stories"
    highlights_dir = main_dir / "highlights"
    
    for directory in [posts_dir, stories_dir, highlights_dir]:
        directory.mkdir(exist_ok=True)
    
    # Initialize instaloader
    L = instaloader.Instaloader(
        dirname_pattern=str(posts_dir),
        download_pictures=True,
        download_videos=True,
        download_video_thumbnails=False,
        download_geotags=False,
        download_comments=False,
        save_metadata=True,
        compress_json=False,
        post_metadata_txt_pattern=""
    )
    
    try:
        # Get profile
        profile = instaloader.Profile.from_username(L.context, profile_name)
        print(f"Downloading content from: {profile.username}")
        print(f"Total posts: {profile.mediacount}")
        print(f"Total followers: {profile.followers}")
        
        # Download posts
        print("\nDownloading posts...")
        for post in profile.get_posts():
            L.download_post(post, target=profile.username)
        print("Posts download completed!")
        
        # Download stories
        print("\nDownloading stories...")
        L.dirname_pattern = str(stories_dir)
        for story in L.get_stories(userids=[profile.userid]):
            for item in story.get_items():
                L.download_storyitem(item, target=f"{profile.username}_stories")
        print("Stories download completed!")
        
        # Download highlights
        print("\nDownloading highlights...")
        L.dirname_pattern = str(highlights_dir)
        for highlight in L.get_highlights(user=profile):
            for item in highlight.get_items():
                L.download_storyitem(item, target=f"{profile.username}_highlights")
        print("Highlights download completed!")
        
        print(f"\n‚úÖ All downloads completed successfully!")
        print(f"üìÅ Files saved in: {main_dir}")
        
    except instaloader.exceptions.ProfileNotExistsException:
        print(f"‚ùå Profile '{profile_name}' does not exist.")
    except instaloader.exceptions.PrivateProfileNotFollowedException:
        print(f"‚ùå Profile '{profile_name}' is private. Login required.")
    except Exception as e:
        print(f"‚ùå An error occurred: {str(e)}")

if __name__ == "__main__":
    # Get username from user
    username = input("Enter Instagram username: ").strip()
    
    if username:
        download_instagram_profile(username)
    else:
        print("Please enter a valid username.")


03 - photo.py
############################################################

import os
import subprocess

# -------- SETTINGS --------
input_folder = "convert"  # folder with videos
output_root = "photos"    # main folder for frames
os.makedirs(output_root, exist_ok=True)

# supported video extensions
video_exts = (".mp4", ".mkv", ".avi", ".mov", ".webm", ".flv", ".wmv")

# -------- PROCESS VIDEOS --------
for file in os.listdir(input_folder):
    if not file.lower().endswith(video_exts):
        continue

    input_path = os.path.join(input_folder, file)
    name, ext = os.path.splitext(file)

    print(f"\nProcessing video: {file}")

    # create folder for this video's frames
    out_folder = os.path.join(output_root, name)
    os.makedirs(out_folder, exist_ok=True)

    # extract frames
    # frames will be named: frame_0001.png, frame_0002.png, ...
    ffmpeg_cmd = [
        "ffmpeg",
        "-y",
        "-i", input_path,
        os.path.join(out_folder, "frame_%04d.png")
    ]
    subprocess.run(ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)

    print(f"‚úÖ Frames saved in {out_folder}")

print("\nüéâ All videos converted to frames!")



04 - crop.py
############################################################

import cv2

video_path = "ScreenRecorderProject1.mp4"
cap = cv2.VideoCapture(video_path)

paused = False
points = []

# Get original video resolution
video_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
video_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

cv2.namedWindow("Video", cv2.WINDOW_NORMAL)
cv2.resizeWindow("Video", video_width, video_height)  # set to original video size

def mouse(event, x, y, flags, param):
    global points
    if event == cv2.EVENT_LBUTTONDOWN and len(points) < 2:
        points.append((x, y))
        print("Point:", x, y)

cv2.setMouseCallback("Video", mouse)

while cap.isOpened():
    if not paused:
        ret, frame = cap.read()
        if not ret:
            break

    display = frame.copy()

    # draw rectangle
    if len(points) == 2:
        cv2.rectangle(
            display,
            points[0],
            points[1],
            (0, 255, 0),
            2
        )

        x1, y1 = points[0]
        x2, y2 = points[1]
        print(f"CROP -> x:{x1}, y:{y1}, w:{x2-x1}, h:{y2-y1}")

    cv2.imshow("Video", display)

    key = cv2.waitKey(30)
    if key == 32:  # SPACE
        paused = not paused
    elif key == 27:  # ESC
        break
    elif key == ord('r'):  # reset points
        points = []

cap.release()
cv2.destroyAllWindows()



05 - Crop_videos.py
############################################################

import os
import subprocess

# ===== SETTINGS =====
input_folder = input(r"Enter the videos folder path: ")
output_folder = "cropped"

# crop values (from your points)
x = 502
y = 100
w = 345
h = 610
# ====================

os.makedirs(output_folder, exist_ok=True)

video_exts = (".mp4", ".mkv", ".avi", ".mov", ".webm", ".flv", ".wmv")

for file in os.listdir(input_folder):
    if file.lower().endswith(video_exts):
        in_path = os.path.join(input_folder, file)
        out_path = os.path.join(output_folder, file)

        print(f"Cropping: {file}")

        cmd = [
            "ffmpeg",
            "-y",
            "-i", in_path,
            "-vf", f"crop={w}:{h}:{x}:{y}",
            "-c:a", "copy",
            out_path
        ]

        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)

print("‚úÖ Done. All videos cropped.")



06 - upload_fit.py
############################################################

import subprocess
import sys
from pathlib import Path
from tqdm import tqdm

VIDEO_EXTENSIONS = {".mkv", ".mp4", ".avi", ".mov", ".webm", ".flv", ".ts"}

def is_video(file):
    return file.suffix.lower() in VIDEO_EXTENSIONS

def run(cmd):
    return subprocess.run(
        cmd,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL
    ).returncode == 0

def remux(input_file, output_file):
    return run([
        "ffmpeg", "-y",
        "-i", str(input_file),
        "-c", "copy",
        "-movflags", "+faststart",
        str(output_file)
    ])

def reencode(input_file, output_file):
    return run([
        "ffmpeg", "-y",
        "-i", str(input_file),

        # Video: Telegram-safe, high quality
        "-c:v", "libx264",
        "-preset", "slow",
        "-crf", "18",
        "-pix_fmt", "yuv420p",
        "-profile:v", "high",
        "-level", "4.1",

        # Audio: Telegram-safe
        "-c:a", "aac",
        "-b:a", "160k",

        "-movflags", "+faststart",
        str(output_file)
    ])

def main():
    if len(sys.argv) != 2:
        print("Usage: python telegram_fix.py <folder_path>")
        sys.exit(1)

    input_dir = Path(sys.argv[1]).resolve()
    if not input_dir.is_dir():
        print("‚ùå Invalid folder path")
        sys.exit(1)

    output_dir = Path(__file__).parent / "telegram_ready"
    output_dir.mkdir(exist_ok=True)

    videos = [v for v in input_dir.iterdir() if v.is_file() and is_video(v)]

    if not videos:
        print("‚ö†Ô∏è No video files found")
        return

    print(f"üé¨ Found {len(videos)} videos")
    print(f"üìÅ Output: {output_dir}\n")

    for video in tqdm(videos, desc="Processing", unit="video"):
        out = output_dir / f"{video.stem}.mp4"

        # 1) Try no-loss remux
        if remux(video, out):
            continue

        # 2) If remux fails, re-encode
        if out.exists():
            out.unlink()

        if not reencode(video, out):
            print(f"\n‚ùå Failed: {video.name}")

    print("\n‚úÖ DONE ‚Äî all videos Telegram compatible")

if __name__ == "__main__":
    main()



07 - cut_videos.py
############################################################

import os
import subprocess

input_folder = input(r"recut: ")
output_folder = "cut"

os.makedirs(output_folder, exist_ok=True)

video_exts = (".mp4", ".mkv", ".avi", ".mov", ".webm", ".flv", ".wmv")

for file in os.listdir(input_folder):
    if not file.lower().endswith(video_exts):
        continue

    print("\n==============================")
    print(f"Video: {file}")

    input_path = os.path.join(input_folder, file)
    name, ext = os.path.splitext(file)

    clip_index = 1

    while True:
        start_min = input("Start minute (Enter to skip video): ")
        if start_min == "":
            break

        start_min = int(start_min)
        start_sec = int(input("Start second: "))

        end_min = int(input("End minute: "))
        end_sec = int(input("End second: "))

        start_time = start_min * 60 + start_sec
        end_time = end_min * 60 + end_sec
        duration = end_time - start_time

        if duration <= 0:
            print("‚ùå Invalid time range. Try again.")
            continue

        output_path = os.path.join(
            output_folder,
            f"{name}_clip{clip_index}{ext}"
        )

        cmd = [
            "ffmpeg",
            "-y",
            "-ss", str(start_time),
            "-i", input_path,
            "-t", str(duration),
            "-c", "copy",
            output_path
        ]

        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)

        print(f"‚úÖ Saved: {output_path}")
        clip_index += 1

        more = input("Add another clip from this video? (y/n): ").lower()
        if more != "y":
            break

print("\nüéâ All videos processed.")



08 - notetext.py
############################################################

import os
from datetime import datetime

def extract_date_from_name(filename):
    """
    Tries to extract a date from filename.
    Expected examples:
    2024-01-15_notes.txt
    15-01-2024.txt
    """
    for fmt in ("%Y-%m-%d", "%d-%m-%Y", "%Y%m%d"):
        try:
            return datetime.strptime(filename[:10], fmt)
        except:
            pass
    return None

def main():
    folder_path = input("Enter folder path: ").strip()
    if not os.path.isdir(folder_path):
        print("‚ùå Invalid folder path")
        return

    txt_files = []

    for file in os.listdir(folder_path):
        if file.lower().endswith(".txt"):
            full_path = os.path.join(folder_path, file)

            # 1Ô∏è‚É£ try date from filename
            date = extract_date_from_name(file)

            # 2Ô∏è‚É£ fallback to metadata date
            if date is None:
                date = datetime.fromtimestamp(os.path.getmtime(full_path))

            txt_files.append((date, file, full_path))

    # sort by date
    txt_files.sort(key=lambda x: x[0])

    output_path = os.path.join(folder_path, "merged_output.txt")

    with open(output_path, "w", encoding="utf-8") as out:
        for i, (_, file, path) in enumerate(txt_files, start=1):
            out.write(f"{i:02d} - {file}\n")
            out.write("-" * 40 + "\n")

            with open(path, "r", encoding="utf-8") as f:
                out.write(f.read())

            out.write("\n\n")

    print(f"‚úÖ Done! File created: {output_path}")

if __name__ == "__main__":
    main()
#i changed this code to the last puch a
#make sure to update it later

p = int(input("22"))


09 - telegram_folder_organizer.py
############################################################

import os

topics = [
    "Lesbian",
    "Sxe",
    "Sxy",
    "Nude",
    "Masturbation",
    "Black",
    "Dance",
    "Extreme",
    "CCTV",
    "Cum",
    "Gay",
    "Voyeur",
    "Arab Sxe",
    "ÿØŸäÿßÿ´ÿ©",
    "Kids with man",
    "kids with women",
    "kids",
    "kids nude"
]

base_dir = "Telegram_Topics"

os.makedirs(base_dir, exist_ok=True)

for topic in topics:
    path = os.path.join(base_dir, topic)
    os.makedirs(path, exist_ok=True)
    print(f"Created: {path}")

    print("You succuded")


10 - img_to_pdf.py
############################################################

import os
from PIL import Image

# Get root folder path
path = input("Enter folder path: ").strip()

# Supported image extensions
image_exts = (".jpg", ".jpeg", ".png", ".bmp", ".tiff", ".webp")

for subfolder in os.listdir(path):
    subfolder_path = os.path.join(path, subfolder)

    if os.path.isdir(subfolder_path):
        images = []

        # Collect images in subfolder
        for file in sorted(os.listdir(subfolder_path)):
            if file.lower().endswith(image_exts):
                img_path = os.path.join(subfolder_path, file)
                img = Image.open(img_path).convert("RGB")
                images.append(img)

        # Create PDF if images exist
        if images:
            pdf_path = os.path.join(subfolder_path, f"{subfolder}.pdf")
            images[0].save(
                pdf_path,
                save_all=True,
                append_images=images[1:]
            )
            print(f"Created: {pdf_path}")
        else:
            print(f"No images in: {subfolder_path}")



11 - number_pdf.py
############################################################

import os
from PyPDF2 import PdfReader, PdfWriter
from reportlab.pdfgen import canvas
from io import BytesIO

root_path = input("Enter folder path: ").strip()

def add_page_numbers(pdf_path):
    reader = PdfReader(pdf_path)
    writer = PdfWriter()

    for i, page in enumerate(reader.pages):
        packet = BytesIO()
        page_width = float(page.mediabox.width)
        page_height = float(page.mediabox.height)

        c = canvas.Canvas(packet, pagesize=(page_width, page_height))

        # BIG and visible page number
        c.setFont("Helvetica-Bold", 28)
        c.drawCentredString(
            page_width / 2,
            50,          # higher from bottom
            str(i + 1)
        )

        c.save()
        packet.seek(0)

        overlay = PdfReader(packet)
        page.merge_page(overlay.pages[0])
        writer.add_page(page)

    with open(pdf_path, "wb") as f:
        writer.write(f)

    print(f"Numbered: {pdf_path}")

for subfolder in os.listdir(root_path):
    subfolder_path = os.path.join(root_path, subfolder)

    if os.path.isdir(subfolder_path):
        for file in os.listdir(subfolder_path):
            if file.lower().endswith(".pdf"):
                add_page_numbers(os.path.join(subfolder_path, file))



12 - pdf_nup.py
############################################################

import os
from PyPDF2 import PdfReader, PdfWriter, PageObject
from reportlab.lib.pagesizes import A4

root_path = input("Enter folder path: ").strip()

def make_2up(pdf_path):
    reader = PdfReader(pdf_path)
    writer = PdfWriter()

    page_width, page_height = A4
    pages = reader.pages
    i = 0

    while i < len(pages):
        new_page = PageObject.create_blank_page(
            width=page_width,
            height=page_height
        )

        # First page (top)
        p1 = pages[i]
        p1.scale_by(0.5)  # correct method in PyPDF2 3.x
        new_page.mergeTranslatedPage(
            p1,
            0,
            page_height / 2
        )

        # Second page (bottom) if exists
        if i + 1 < len(pages):
            p2 = pages[i + 1]
            p2.scale_by(0.5)
            new_page.mergeTranslatedPage(
                p2,
                0,
                0
            )

        writer.add_page(new_page)
        i += 2

    out_path = pdf_path.replace(".pdf", "_2up.pdf")
    with open(out_path, "wb") as f:
        writer.write(f)

    print(f"2-up created: {out_path}")

# Walk through folders
for subfolder in os.listdir(root_path):
    subfolder_path = os.path.join(root_path, subfolder)
    if os.path.isdir(subfolder_path):
        for file in os.listdir(subfolder_path):
            if file.lower().endswith(".pdf") and not file.endswith("_2up.pdf"):
                make_2up(os.path.join(subfolder_path, file))



13 - topic_names.py
############################################################

from telethon.sync import TelegramClient
from telethon.tl.types import Channel, Chat

# Your API credentials
api_id = 29949213
api_hash = "cd78d1e37a6666756a5483ec22f6a84a"

client = TelegramClient('session_name', api_id, api_hash)
client.start()

# Step 1: List all groups you are in
dialogs = client.get_dialogs()
groups = []

print("Your groups:")
for i, d in enumerate(dialogs):
    if isinstance(d.entity, (Channel, Chat)) and d.is_group:
        print(f"{i}: {d.name}")
        groups.append(d.entity)

# Step 2: Pick a group by number
index = int(input("Enter the number of the group you want to fetch messages from: "))
group = groups[index]

# Step 3: Fetch and print recent messages (up to 100)
print(f"\nLast 100 messages in '{group.title if hasattr(group, 'title') else group.name}':")
for msg in client.iter_messages(group, limit=100):
    print(f"- {msg.text}")



14 - duplicate.py
############################################################

import os
import hashlib
import shutil

# Paths - update these to your actual folders
folder1 = input(r"Path\To\Folder1: ")  # folder with subfolders
folder2 = input(r"Path\To\Folder2: ")  # flat folder
output_folder = input(r"Path\To\Unique_Folder2: ")

# Create output folder if it doesn't exist
os.makedirs(output_folder, exist_ok=True)

def hash_file(path):
    """Return SHA-256 hash of a file"""
    sha256 = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            sha256.update(chunk)
    return sha256.hexdigest()

# Step 1: Scan Folder1 recursively and hash all files
folder1_hashes = {}
for root, dirs, files in os.walk(folder1):
    for file in files:
        full_path = os.path.join(root, file)
        file_hash = hash_file(full_path)
        folder1_hashes[file_hash] = full_path

# Step 2: Scan Folder2 and check for duplicates
duplicates = []
unique_count = 0

for file in os.listdir(folder2):
    full_path = os.path.join(folder2, file)
    if os.path.isfile(full_path):
        file_hash = hash_file(full_path)
        if file_hash in folder1_hashes:
            duplicates.append(file)
        else:
            # Copy unique files to output folder
            shutil.copy2(full_path, os.path.join(output_folder, file))
            unique_count += 1

# Step 3: Print results
if duplicates:
    print("Duplicates found in Folder2 that exist in Folder1:")
    for d in duplicates:
        print(d)
else:
    print("No duplicates found. All files in Folder2 are unique.")

print(f"\nUnique files from Folder2 copied to: {output_folder}")
print(f"Total unique files: {unique_count}")



15 - pyfiles.py
############################################################

import os
from datetime import datetime

def extract_date_from_name(filename):
    """
    Tries to extract a date from filename.
    Expected examples:
    2024-01-15_script.py
    15-01-2024.py
    20240115_utils.py
    """
    for fmt in ("%Y-%m-%d", "%d-%m-%Y", "%Y%m%d"):
        try:
            return datetime.strptime(filename[:10], fmt)
        except ValueError:
            pass
    return None


def main():
    folder_path = input("Enter folder path: ").strip()

    if not os.path.isdir(folder_path):
        print("‚ùå Invalid folder path")
        return

    py_files = []

    for file in os.listdir(folder_path):
        if file.lower().endswith(".py"):
            full_path = os.path.join(folder_path, file)

            # 1Ô∏è‚É£ try date from filename
            date = extract_date_from_name(file)

            # 2Ô∏è‚É£ fallback to file modified time
            if date is None:
                date = datetime.fromtimestamp(os.path.getmtime(full_path))

            py_files.append((date, file, full_path))

    # sort by date
    py_files.sort(key=lambda x: x[0])

    output_path = os.path.join(folder_path, "merged_python_code.txt")

    with open(output_path, "w", encoding="utf-8") as out:
        for i, (_, file, path) in enumerate(py_files, start=1):
            out.write(f"{i:02d} - {file}\n")
            out.write("#" * 60 + "\n\n")

            with open(path, "r", encoding="utf-8") as f:
                out.write(f.read())

            out.write("\n\n\n")

    print(f"‚úÖ Done! File created: {output_path}")


if __name__ == "__main__":
    main()



